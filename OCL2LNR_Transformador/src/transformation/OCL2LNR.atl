-- @nsURI OCL=http://www.eclipse.org/ocl/2015/Pivot
-- @nsURI LNR=http://www.xtext.org/tesis/gramatica/Gramatica


module OCL2LNR;
create OUT: LNR from IN: OCL;

--uses strings;
-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER: getPackageName
-- Returns name of the first package defined
-- OUT:		String
helper def: getPackageName: String =
	thisModule.removePrefix(OCL!Model.allInstances().first().ownedPackages.first().toString());

-- HELPER: removePrefix
-- Returns string after removing anything before ! if exists.
-- OUT:		String
helper def: removePrefix(str: String): String =
	let idx : Integer = str.indexOf('!') + 2 in
	if ( idx > 0) then
		str.substring(idx, str.size())
	else
		str
	endif;

-- HELPER: operationName
-- Returns string the complete name for the operation passed as param. Eg. > return 'mayor que'
-- OUT:		String
helper def: operationName(str: String): String =
	if ( str = '>') then 'mayor que'
	else if ( str = '<') then 'menor que'
		 else if ( str = '<=') then 'menor o igual a'
		      else if ( str = '>=') then 'mayor o igual a'
			  	   else if ( str = '=') then 'igual a'
				   		else if ( str = '<>') then 'distinto de'
							 else OclUndefined
							endif
						endif
					endif
			  endif
		 endif
	endif;

helper context OclAny def: getExpressionInOCL() : OCL!ExpressionInOCL =
--	let 
--		parent: OclAny = self.refImmediateComposite()
--	in
	if self.refImmediateComposite().oclIsTypeOf(OCL!ExpressionInOCL) then
		self.refImmediateComposite()
	else if self.refImmediateComposite().oclIsUndefined() then
			OclUndefined
		else 
			self.refImmediateComposite().getExpressionInOCL()
		endif
	endif;

helper context OCL!PrimitiveLiteralExp def: getLiteralSymbol() : String = 
   if (self.oclIsTypeOf(OCL!StringLiteralExp)) then 
   		self.stringSymbol
   else if (self.oclIsTypeOf(OCL!IntegerLiteralExp)) then
   			self.integerSymbol.toString()
   		else
   			OclUndefined
   		endif
   endif;
   
-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------
rule Model2Documento {
	from
		s: OCL!Model (
			s.oclIsTypeOf(OCL!Model)
		)
	to
		t2: LNR!Documento (
			pathModelo <- s.ownedPackages.first().URI,
			pathOcl <- s.externalURI
			, oraciones <- s.ownedPackages.first().ownedClasses->collect(e | e.ownedInvariants).flatten()
		)
}

rule Constraint2Oracion {
	from
		s : OCL!Constraint
	to 
		t : LNR!Oracion ( 
			contenido <- s.ownedSpecification.ownedBody
		)
}

lazy rule ExpressionInOCL2SintagmaPreposicional {
	from
		s : OCL!ExpressionInOCL
	to 
		sp: LNR!SintagmaPreposicional ( 
			enlace <- e, 
			termino <- t
		),
		e: LNR!Enlace (
			valor <- 'de'
		),
		t: LNR!Termino (
			indeterminante <- i,
			contexto <- c
			),
		i: LNR!Indeterminante (
			valor <- 'un/una'		
		),
		c: LNR!Contexto (
			nombre <- if (s.oclIsUndefined()) then OclUndefined else s.owningConstraint.context.name endif	
		) 
}
		


rule OperationCallExp2Simple {
	from
		s: OCL!OperationCallExp (s.name <> 'and' and s.name <> 'notEmpty' ) 
	to
		t2: LNR!Simple (
				--extraStr <- s.getBody() + s.ownedBody.name + s.ownedBody.oclIsTypeOf(OCL!OperationCallExp).toString() ,
				determinante <- d,
				atributo <- a,
				sintagma <- thisModule.ExpressionInOCL2SintagmaPreposicional(s.getExpressionInOCL()), 
				obligacion <- ob, 
				operacion <- op, 
				literal <- l 
		),
		d: LNR!Determinante (valor <- 'El/La'),
		a: LNR!Atributo (
			--prefijo <- 'prefix', --+ s.ownedBody.ownedSource.referredProperty.oclIsKindOf(OCL!ReferringElement),
			nombre <- if (s.oclIsTypeOf(OCL!OperationCallExp)) then 
						if (s.ownedSource.oclIsTypeOf(OCL!PropertyCallExp)) then
						     thisModule.removePrefix(s.ownedSource.referredProperty.toString())
						else --not (self.titulo <> '')) tengo que bajar un nivel para poder retornar el atributo, hay que ver que pasa con multiples niveles.
							 if (s.ownedSource.oclIsTypeOf(OCL!OperationCallExp)) then
						     	--'test'+s.ownedBody.ownedSource.ownedSource.referredProperty.toString()
							 	thisModule.removePrefix(s.ownedSource.ownedSource.referredProperty.toString())
							 else 
							 	OclUndefined
							 endif
						endif
					else
						'no es opCall'+s.ownedSource.oclType().toString()
					endif
		),
		ob: LNR!Obligacion (
			negacion <- if (s.name = 'not') then 
							'no'
						else
							OclUndefined
						endif,
			obligacionDeber <- 'debe ser' 
			), 
		op: LNR!Operacion(
			descripcion <-  if(s.name = 'not')then 
								thisModule.operationName(s.ownedSource.name)
						   	else
						   		thisModule.operationName(s.name)
							endif
			),
		l: LNR!Literal (
			valor <- if(s.name = 'not') then 
	 				 	s.ownedSource.ownedArguments.first().getLiteralSymbol()
					 else 
					 	s.ownedArguments.first().getLiteralSymbol()
					 endif)
			
}	

--Generar otra regla para simples donde el atributo es una coleccion. 
rule OperationCallExp2Compuesta {
	from
		s: OCL!OperationCallExp (s.name = 'and' and s.name <> 'notEmpty')
	to
		t2: LNR!Compuesta(
			simple <- s.ownedArguments.first(),
			nexo <- n,
			oracion <- o
		),
		n: LNR!Nexo(valor <- 'y'),
		o: LNR!Oracion (
		  contenido <- s.ownedSource
		)

}	
