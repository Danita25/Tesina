-- @nsURI OCL=http://www.eclipse.org/ocl/2015/Pivot
-- @nsURI LNR=http://www.xtext.org/tesis/gramatica/Gramatica


module OCL2LNR;
create OUT: LNR from IN: OCL;

--uses strings;
-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER: getPackageName
-- Returns name of the first package defined
-- OUT:		String
helper def: getPackageName: String =
	thisModule.removePrefix(OCL!Model.allInstances().first().ownedPackages.first().toString());

-- HELPER: removePrefix
-- Returns string after removing anything before ! if exists.
-- OUT:		String
helper def: removePrefix(str: String): String =
	let idx: Integer =
		str.indexOf('!') + 2
	in
		if (idx > 0) then
			str.substring(idx, str.size())
		else
			str
		endif;

-- HELPER: operationName
-- Returns string the complete name for the operation passed as param. Eg. > return
		-- 'mayor que'
-- OUT:		String
helper def: operationName(str: String): String =
	if (str = '>') then
		'mayor que'
	else
		if (str = '<') then
			'menor que'
		else
			if (str = '<=') then
				'menor o igual a'
			else
				if (str = '>=') then
					'mayor o igual a'
				else
					if (str = '=') then
						'igual a'
					else
						if (str = '<>') then
							'distinto de'
						else
							if ( str = 'isEmpty') then 'igual a'
							else if ( str = 'notEmpty') then 'mayor que'
								else OclUndefined
								endif
							endif
						endif
					endif
				endif
			endif
		endif
	endif;

helper context OclAny def: getExpressionInOCL(): OCL!ExpressionInOCL =
	--	let 
--		parent: OclAny = self.refImmediateComposite()
--	in
	if self.refImmediateComposite().oclIsTypeOf(OCL!ExpressionInOCL) then
		self.refImmediateComposite()
	else if self.refImmediateComposite().oclIsUndefined() then
			OclUndefined
		else
			self.refImmediateComposite().getExpressionInOCL()
		endif
	endif;

helper context OCL!PrimitiveLiteralExp def: getLiteralSymbol(): String =
	if (self.oclIsTypeOf(OCL!StringLiteralExp)) then
		self.stringSymbol
	else
		if (self.oclIsTypeOf(OCL!IntegerLiteralExp)) then
			self.integerSymbol.toString()
		else
			OclUndefined
		endif
	endif;

helper context OCL!OCLExpression def: getPropertyName(): String =
	if (self.oclIsTypeOf(OCL!PropertyCallExp)) then
		thisModule.removePrefix(self.referredProperty.toString())
	else if (self.oclIsTypeOf(OCL!OperationCallExp) and not self.referredOperation.oclIsUndefined()) then
		thisModule.operationName(thisModule.removePrefix(self.referredOperation.toString()))
	else
		self.ownedSource.getPropertyName()
	endif
	endif;

-- HELPER: haveCollectionExpInSources
-- Checks if there is CollectionOperation in sources (source.source.etc) of expression.
-- CONTEXT:	CallExp
-- OUT:		Boolean
helper context OCL!OperationCallExp def: haveCollectionExpInSources(): Boolean =
	if self.oclIsTypeOf(OCL!OperationCallExp) and ( thisModule.removePrefix(self.
			referredOperation.toString()) = 'size' or thisModule.removePrefix(self.
			referredOperation.toString()) = 'notEmpty' or thisModule.removePrefix(self.
			referredOperation.toString()) = 'isEmpty'
			) then
		true
	else
		if not self.ownedSource.oclIsUndefined() then
			if self.ownedSource.oclIsKindOf(OCL!OperationCallExp) then
				self.ownedSource.haveCollectionExpInSources()
			else
				false
			endif
		else
			false
		endif
	endif;

-- HELPER: haveCollectionExpInArguments
-- Checks if there is CollectionOperation in arguments of expression.
-- CONTEXT:	OperationCallExp
-- OUT:		Boolean
helper context OCL!OperationCallExp def: haveCollectionExpInArguments(): Boolean =
	if self.argument -> asSequence() -> first().
			oclIsTypeOf(OCL!CollectionOperationCallExp) then
		true
	else
		if self.argument -> size() > 0 then
			if self.argument -> asSequence() -> first().oclIsKindOf(OCL!OperationCallExp)
					then
				self.argument -> asSequence() -> first().haveCollectionExpInArguments()
			else
				false
			endif
		else
			false
		endif
	endif;

helper context OCL!PropertyCallExp def: getPropertyCallExpCollection() : Sequence(OCL!PropertyCallExp) =
let elements : Sequence(OCL!PropertyCallExp) = Sequence{} in
		if self.ownedSource.oclIsTypeOf(OCL!PropertyCallExp) then
			elements.append(self).union(self.ownedSource.getPropertyCallExpCollection()) 
		else
			elements.append(self) -- LEAF
		endif
	;

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------
rule Model2Documento {
	from
		s: OCL!Model (
			s.oclIsTypeOf(OCL!Model)
		)
	to
		t2: LNR!Documento (
			pathModelo <- s.ownedPackages.first().URI,
			pathOcl <- s.externalURI,
			oraciones <- s.ownedPackages.first().ownedClasses -> collect(e | e.
					ownedInvariants).flatten()
		)
}

rule Constraint2Oracion {
	from
		s: OCL!Constraint
	to
		t: LNR!Oracion (
			contenido <- s.ownedSpecification.ownedBody--thisModule.OperationCallExp2Contenido(s.ownedSpecification.ownedBody)
		)
}



--Operation Call Exp
rule OperationCallExp2ContenidoSimple {
	from
		s: OCL!OperationCallExp (s.name <> 'and' and s.name <> 'or')
	to 
		t1: LNR!Contenido(simple <-  thisModule.OperationCallExp2Simple(s))
}

rule OperationCallExp2ContenidoAndOr  {
	from
		s: OCL!OperationCallExp (s.name = 'and' or s.name = 'or')
	to
		t2: LNR!Contenido (
			simple <- thisModule.OperationCallExp2Simple(s.ownedArguments.first()),
			composicion <- c
		),
		c: LNR!Composicion (
			nexo <- n,
			contenido <- thisModule.resolveTemp(s.ownedSource, 't1')
		)
		,
		n: LNR!Nexo (
			valor <- 	if s.name = 'and' then 'y'
						else if s.name = 'or' then 'o'
							 else	OclUndefined
							endif
				endif
		)
}

lazy rule OperationCallExp2Simple {
	from
		s: OCL!OperationCallExp
	to 
		simple: LNR!Simple (
			expresion_izq <- if (s.name = 'not') then thisModule.OCLExpression2Expresion(s.ownedSource.ownedSource)
							 else if (thisModule.removePrefix(s.referredOperation.toString()) = 'isEmpty') 
							 			or (thisModule.removePrefix(s.referredOperation.toString()) = 'notEmpty') then --ver si se puede hacer preguntando por s.name undefined, no porque afecta al size
							 			thisModule.OCLExpression2Expresion(s) -- call with parent para poder generar la comparacion
								 else thisModule.OCLExpression2Expresion(s.ownedSource)
								 endif
							endif,
			comparacion <- cp,
			expresion_der <- if (s.name = 'not') then thisModule.OCLExpression2Expresion(s.ownedSource.ownedArguments.first())
							 else if (thisModule.removePrefix(s.referredOperation.toString()) = 'isEmpty') 
							 			or (thisModule.removePrefix(s.referredOperation.toString()) = 'notEmpty') then --ver si se puede hacer preguntando por s.name undefined, no porque afecta al size
							 			zero --Exp_der es 0 ya que si es isEmpty sera = 0 y si es not empty sera > 0. 
							 	else thisModule.OCLExpression2Expresion(s.ownedArguments.first())
							 		endif
							endif
			),
		zero: LNR!Expresion(expresion <- zeroLit),
		zeroLit: LNR!Literal(valor <- '0'),
		cp: LNR!Comparacion (
			obligacion <- ob,
			operacion <- op	
		),
		ob: LNR!Obligacion (
			negacion <- if (s.name = 'not') then
					'no'
				else
					OclUndefined
				endif,
			obligacion <- 'debe ser'
		),
		op: LNR!Operacion (
			operacion <- if (s.name = 'not') then
							thisModule.operationName(s.ownedSource.name)
						else if ( s.name.oclIsUndefined()) then  --si es undefined es porque es una operacion de colecciones como size, empty, not empty
								thisModule.operationName(thisModule.removePrefix(s.referredOperation.toString()))
							else	thisModule.operationName(s.name)
							endif
						endif
		)

}

lazy rule OCLExpression2Expresion {
	from
		s: OCL!OCLExpression
	to 
		t : LNR!Expresion (
			expresion <- if (s.oclIsKindOf(OCL!PrimitiveLiteralExp)) then--crear objecto literal?
									thisModule.PrimitiveLiteralExp2Literal(s)		
--						  else if (thisModule.removePrefix(s.referredOperation.toString()) = 'isEmpty')
--						  		or  (thisModule.removePrefix(s.referredOperation.toString()) = 'notEmpty') then 
--								    thisModule.PrimitiveLiteralExp2Literal(s)	
						  else if (s.oclIsTypeOf(OCL!PropertyCallExp)) then-- crear objeto propiedad
									thisModule.PropertyCallExp2Propiedad(s)
						  else if (s.oclIsTypeOf(OCL!OperationCallExp)) then-- crear objeto propiedad
									thisModule.OperationCallExp2Propiedad(s)
						  else OclUndefined
--						  endif
						  endif
						  endif
						  endif
		)
}


lazy rule PrimitiveLiteralExp2Literal {
	from
		s: OCL!PrimitiveLiteralExp
	to 
		t: LNR!Literal (
			valor <- s.getLiteralSymbol())
}

lazy rule PropertyCallExp2Atributo {
	from
		s: OCL!PropertyCallExp
	to 
		a: LNR!Atributo ( 
			determinante <- 'el/la', 
			nombre <- s.getPropertyName(),
			enlace <- 'de'
		)
}

lazy rule PropertyCallExp2Propiedad {
	from
		s: OCL!PropertyCallExp
	using {children : Sequence(OCL!PropertyCallExp) = s.getPropertyCallExpCollection();}
	to 
		p: LNR!Propiedad (
			atributo <- children->collect(e |  thisModule.PropertyCallExp2Atributo(e)), 
			termino <- t
		), 
		t: LNR!Termino (
			indeterminante <- 'un/una',
			contexto <-  if (s.oclIsUndefined()) then
							OclUndefined
						else
							s.getExpressionInOCL().owningConstraint.context.name
						endif
		)
}


lazy rule OperationCallExp2Propiedad {
	from
		s: OCL!OperationCallExp
	using {children : Sequence(OCL!PropertyCallExp) = s.ownedSource.getPropertyCallExpCollection();}
	to 
		p: LNR!Propiedad (
			atributo <- children->collect(e | thisModule.PropertyCallExp2Atributo(e)), 
			termino <- t
		), 
		t: LNR!Termino (
			indeterminante <- 'un/una',
			contexto <-  if (s.oclIsUndefined()) then
							OclUndefined
						else
							s.getExpressionInOCL().owningConstraint.context.name
						endif
		)
	do {
		p.atributo.first().prefijo <- 'cantidad de';
	}
}



--
----Colecciones operations son distintas no se pueden acceder por name.
--lazy rule OperationCallExp2Operacion {
--	from
--		s: OCL!OperationCallExp
--	to
--		op: LNR!Operacion (
--			descripcion <- thisModule.operationName(thisModule.removePrefix(s.
--					referredOperation.toString()))
--		)
--}
--
--rule OperationCallExp2Coleccion {
--	from
--		s: OCL!OperationCallExp (
--			thisModule.removePrefix(s.referredOperation.toString()) = 'notEmpty' or
--					thisModule.removePrefix(s.referredOperation.toString()) = 'isEmpty'
--					or thisModule.removePrefix(s.referredOperation.toString()) = 'size'
--		)
--	to
--		t2: LNR!Coleccion (
--			termino <- t,
--			obligacion <- ob,
--			operando <- ope,
--			operacion <- if (thisModule.removePrefix(s.referredOperation.toString()) =
--					'notEmpty' or thisModule.removePrefix(s.referredOperation.toString())
--					= 'isEmpty') then
--					OclUndefined
--				else
--					thisModule.OperationCallExp2Operacion(s)
--				endif --		   operando2 <- if (
--						-- thisModule.removePrefix(s.referredOperation.toString()) =
--						-- 'notEmpty'
----							or thisModule.removePrefix(s.referredOperation.toString())
--		-- = 'isEmpty') 
----						then OclUndefined
----						else 
----							'op2'--op
----						endif
----
--			
--		),
--		t: LNR!Termino (
--			indeterminante <- i,
--			contexto <- c
--		),
--		i: LNR!Indeterminante (
--			valor <- 'un/una'
--		),
--		c: LNR!Contexto (
--			nombre <- if (s.getExpressionInOCL().oclIsUndefined()) then
--					OclUndefined
--				else
--					if s.getExpressionInOCL().owningConstraint.oclIsUndefined() then
--						OclUndefined
--					else
--						s.getExpressionInOCL().owningConstraint.context.name
--					endif
--				endif
--		),
--		ob: LNR!ObligacionColeccion (
--			negacion <- if (thisModule.removePrefix(s.referredOperation.toString()) =
--					'isEmpty') then
--					'no'
--				else
--					OclUndefined
--				endif,
--			obligacionDeber <- 'debe tener'
--		),
--		--		op: LNR!Operacion(
----			descripcion <-  OclUndefined
----			),
--		ope: LNR!Atributo (
--			nombre <- s.ownedSource.getPropertyName()
--		)
--}
