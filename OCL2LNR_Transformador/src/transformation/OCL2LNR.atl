-- @nsURI OCL=http://www.eclipse.org/ocl/2015/Pivot
-- @nsURI LNR=http://www.xtext.org/tesina/LenguajeNaturalReducido


module OCL2LNR;
create OUT: LNR from IN: OCL;

--uses strings;
-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-- HELPER: getPackageName
-- Returns name of the first package defined
-- OUT:		String
helper def: getPackageName: String =
	thisModule.removePrefix(OCL!Model.allInstances().first().ownedPackages.first().toString());

-- HELPER: removePrefix
-- Returns string after removing anything before ! if exists.
-- OUT:		String
helper def: removePrefix(str: String): String =
	let idx: Integer =
		str.indexOf('!') + 2
	in
		if (idx > 0) then
			str.substring(idx, str.size())
		else
			str
		endif;

-- HELPER: operationName
-- Returns string the complete name for the operation passed as param. Eg. > return
-- 'mayor que'
-- OUT:		String
helper def: operationName(str: String): String =
	if (str = '>') then
		'mayor que'
	else
		if (str = '<') then
			'menor que'
		else
			if (str = '<=') then
				'menor o igual a'
			else
				if (str = '>=') then
					'mayor o igual a'
				else
					if (str = '=') then
						'igual a'
					else
						if (str = '<>') then
							'distinto de'
						else
							if (str = 'isEmpty') then
								'igual a'
							else
								if (str = 'notEmpty') then
									'mayor que'
								else
									if (str = 'exists') then
										'mayor que'
									else
--										if (str = 'notExists') then
--											'igual a'
--										else
											OclUndefined
--										endif
									endif
								endif
							endif
						endif
					endif
				endif
			endif
		endif
	endif;

helper context OclAny def: getExpressionInOCL(): OCL!ExpressionInOCL =
	--	let 
--		parent: OclAny = self.refImmediateComposite()
--	in
	if self.refImmediateComposite().oclIsTypeOf(OCL!ExpressionInOCL) then
		self.refImmediateComposite()
	else if self.refImmediateComposite().oclIsUndefined() then
			OclUndefined
		else
			self.refImmediateComposite().getExpressionInOCL()
		endif
	endif;

helper context OCL!PrimitiveLiteralExp def: getLiteralSymbol(): String =
	if (self.oclIsTypeOf(OCL!StringLiteralExp)) then
		self.stringSymbol
	else
		if (self.oclIsTypeOf(OCL!IntegerLiteralExp)) then
			self.integerSymbol.toString()
		else
			if (self.oclIsTypeOf(OCL!BooleanLiteralExp)) then
				self.booleanSymbol.toString()
			else OclUndefined
			endif
		endif
	endif;

helper context OCL!OCLExpression def: getPropertyName(): String =
	if (self.oclIsTypeOf(OCL!PropertyCallExp)) then
		thisModule.removePrefix(self.referredProperty.toString())
	else
		if ( self.oclIsTypeOf(OCL!IteratorExp)) then --DL added for iterator property to be ignored as it will duplicate the entry in the output. 
				OclUndefined--thisModule.removePrefix(self.ownedSource.referredProperty.toString())
		else 
			if (self.oclIsTypeOf(OCL!OperationCallExp) and not self.referredOperation.oclIsUndefined()) then
				thisModule.operationName(thisModule.removePrefix(self.referredOperation.toString()))
			else
				self.ownedSource.getPropertyName()
			endif
		endif
	endif;

-- HELPER: haveCollectionExpInSources
-- Checks if there is CollectionOperation in sources (source.source.etc) of expression.
-- CONTEXT:	CallExp
-- OUT:		Boolean
helper context OCL!OperationCallExp def: haveCollectionExpInSources(): Boolean =
	if self.oclIsTypeOf(OCL!OperationCallExp) and ( thisModule.removePrefix(self.
			referredOperation.toString()) = 'size' or thisModule.removePrefix(self.
			referredOperation.toString()) = 'notEmpty' or thisModule.removePrefix(self.
			referredOperation.toString()) = 'isEmpty'
			) then
		true
	else
		if not self.ownedSource.oclIsUndefined() then
			if self.ownedSource.oclIsKindOf(OCL!OperationCallExp) then
				self.ownedSource.haveCollectionExpInSources()
			else
				false
			endif
		else
			false
		endif
	endif;

helper context OCL!CallExp def: getPropertyCallExpCollection(): -- DL change context from PropertyCallExp to CallExp to avoid isssue with iterators.
		Sequence(OCL!PropertyCallExp) =
	let elements: Sequence(OCL!PropertyCallExp) =
		Sequence{}
	in
		if self.oclIsTypeOf(OCL!IteratorExp) then 
				elements.union(self.ownedSource.getPropertyCallExpCollection())
		else 
			if self.ownedSource.oclIsTypeOf(OCL!PropertyCallExp) then
				elements.append(self).union(self.ownedSource.getPropertyCallExpCollection())
			else
				elements.append(self) -- LEAF
			endif	
	endif;

helper context OCL!IteratorExp def: getIteratorExpCollection(): 
		Sequence(OCL!IteratorExp) =
	let elements: Sequence(OCL!IteratorExp) =
		Sequence{}
	in
			if self.ownedSource.oclIsTypeOf(OCL!IteratorExp) then
				elements.union(self.ownedSource.getIteratorExpCollection()).append(self)
			else
				elements.append(self) -- LEAF
			endif;
	
helper context OCL!PropertyCallExp def: isParentAnIterator(): Boolean =
	if self.refImmediateComposite().oclIsTypeOf(OCL!OperationCallExp) then
		false
	else
		if self.refImmediateComposite().oclIsTypeOf(OCL!IteratorExp) then
			true
		else
			self.refImmediateComposite().isParentAnIterator()
		endif
	endif;

helper context OCL!PropertyCallExp def: parentIteratorName(): String =
	if self.isParentAnIterator() then 
		if self.refImmediateComposite().oclIsTypeOf(OCL!IteratorExp) then
			thisModule.removePrefix(self.refImmediateComposite().referredIteration.name)
		else
			self.refImmediateComposite().parentIteratorName()
		endif
	else 
		OclUndefined
	endif;

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------
rule Model2Documento {
	from
		s: OCL!Model (
			s.oclIsTypeOf(OCL!Model)
		)
	to
		t2: LNR!Documento (
			encabezado <- 'Las siguientes afirmaciones deben ser verdaderas en el sistema:',
			oraciones <- s.ownedPackages.first().ownedClasses -> collect(e | e.
					ownedInvariants).flatten()
		)
}

rule Constraint2Oracion {
	from
		s: OCL!Constraint
	to
		t: LNR!Oracion (
			contenido <- if (s.ownedSpecification.ownedBody.oclIsTypeOf(OCL!IteratorExp)) then 
							thisModule.IteratorExp2Contenido(s.ownedSpecification.ownedBody ) 
						else s.ownedSpecification.ownedBody endif
		)
}

lazy rule String2LiteralExp {
	from
		s: String
	to
		exp: LNR!Expresion (
			expresion <- lit
		),
		lit: LNR!Literal (
			valor <- s
		)
}


--Iterator Exp
lazy rule IteratorExp2Contenido {
	from
		s: OCL!IteratorExp
	to
		c1: LNR!Contenido (
			simple <- thisModule.Iterator2Simple(s),
			composicion <- OclUndefined 
		)
}

lazy rule Iterator2Simple{
	from
		s: OCL!IteratorExp
	to  sp: LNR!Simple (
			expresion_izq <- exp_izq,
			expresion_der <- OclUndefined--if (s.referredIteration.name = 'exists') then exp_der else OclUndefined endif
	)
	, 
	exp_izq: LNR!Expresion(
		expresion <- thisModule.IteratorExp2Propiedad(s)
		)
}

--Operation Call Exp
rule OperationCallExp2ContenidoSimple {
	from
		s: OCL!OperationCallExp (
			s.name <> 'and' and s.name <> 'or' and s.name <> 'implies'
		)
	to
		t1: LNR!Contenido (
			simple <- thisModule.OperationCallExp2Simple(s)
		)
}

rule OperationCallExp2ContenidoAndOr {
	from
		s: OCL!OperationCallExp (
			s.name = 'and' or s.name = 'or' or s.name = 'implies'
		)
	to
		t2: LNR!Contenido (
			prefijo <- if(s.name = 'implies')then 
							'si'
						else OclUndefined
						endif,
			simple <- if(s.name = 'implies')then 
									 thisModule.OperationCallExp2Simple(s.ownedSource)
							else
						    	if(s.ownedSource.oclIsTypeOf(OCL!IteratorExp))then 
									thisModule.Iterator2Simple(s.ownedSource)
								else thisModule.OperationCallExp2Simple(s.ownedArguments.first()) 
								endif
							endif,
			composicion <- c
		),
		c: LNR!Composicion (
			nexo <- n,
			contenido <- if(s.name = 'implies')then
								thisModule.resolveTemp(s.ownedArguments.first(), 't1')
						  else 
						  	if(s.ownedArguments.first().oclIsTypeOf(OCL!IteratorExp))then
								thisModule.IteratorExp2Contenido(s.ownedArguments.first())
						  	else thisModule.resolveTemp(s.ownedSource, 't1')
							endif  
						endif
		),
		n: LNR!Nexo (
			valor <- if s.name = 'and' then
					'y'
				else
					if s.name = 'or' then
						'o'
					else
						if s.name = 'implies' then 
							'entonces'
						else
							OclUndefined
						endif
					endif
				endif
		)
}

lazy rule OperationCallExp2Simple {
	from
		s: OCL!OperationCallExp
	to
		simple: LNR!Simple (
			expresion_izq <- if (s.name = 'not') then
								thisModule.OCLExpression2Expresion(s.ownedSource.ownedSource)
							else
								if (thisModule.removePrefix(s.referredOperation.toString()) ='isEmpty')
								or (thisModule.removePrefix(s.referredOperation.toString()) = 'notEmpty') then
									thisModule.OCLExpression2Expresion(s) -- call with parent para poder generar la comparacion
						
								else
									thisModule.OCLExpression2Expresion(s.ownedSource)
								endif
							endif,
			expresion_der <- expDer), 
		expDer: LNR!ExpresionDerecha (
			comparacion <- cp,
			expresion <- if (s.name = 'not') then
					thisModule.OCLExpression2Expresion(s.ownedSource.ownedArguments.first())
				else
					if (thisModule.removePrefix(s.referredOperation.toString()) =
							'isEmpty') or (thisModule.removePrefix(s.referredOperation.
							toString()) = 'notEmpty') then
						thisModule.String2LiteralExp('0') --Exp_der es 0 ya que si es
								-- isEmpty sera = 0 y si es not empty sera > 0.
						
					else
						thisModule.OCLExpression2Expresion(s.ownedArguments.first())
					endif
				endif
		), 
		cp: LNR!Comparacion (
			obligacion <- ob,
			operacion <- op
		),
		ob: LNR!Obligacion (
			negacion <- if (s.name = 'not') then
					'no'
				else
					OclUndefined
				endif,
			obligacion <- 'es'
		),
		op: LNR!Operacion (
			operacion <- if (s.name = 'not') then
					thisModule.operationName(s.ownedSource.name)
				else
					if (s.name.oclIsUndefined()) then
						--si es undefined es porque es una operacion de colecciones como
								-- size, empty, not empty
						thisModule.operationName(thisModule.removePrefix(s.referredOperation.toString()))
					else
						thisModule.operationName(s.name)
					endif
				endif
		)
}

lazy rule OCLExpression2Expresion {
	from
		s: OCL!OCLExpression
	to
		t: LNR!Expresion (
			expresion <- if (s.oclIsKindOf(OCL!PrimitiveLiteralExp)) then
								--crear objecto literal?
							thisModule.PrimitiveLiteralExp2Literal(s)
						else
							if (s.oclIsTypeOf(OCL!PropertyCallExp)) then
								thisModule.PropertyCallExp2Propiedad(s)
							else
								if (s.oclIsTypeOf(OCL!OperationCallExp)) then  --iterador como hijo entonces prop call con el ownedsource del iterador
									-- crear objeto propiedad
									thisModule.OperationCallExp2Propiedad(s)
								else
									OclUndefined
								endif
							endif
						endif --						  endif
			
		)
}

lazy rule PrimitiveLiteralExp2Literal {
	from
		s: OCL!PrimitiveLiteralExp
	to
		t: LNR!Literal (
			valor <- s.getLiteralSymbol()
		)
}

lazy rule PropertyCallExp2Atributo {
	from
		s: OCL!PropertyCallExp
	to
		a: LNR!Atributo (
			determinante <- 'el/la',
			nombre <- s.getPropertyName(),
			enlace <- 'de'
		)
}

lazy rule PropertyCallExp2Propiedad {
	from
		s: OCL!PropertyCallExp
	using {
		children: Sequence(OCL!PropertyCallExp) = s.getPropertyCallExpCollection();
--		isParentIterator: Boolean = s.isParentAnIterator();
		parentIteratorName: String = s.parentIteratorName();
	}
	to
		p: LNR!Propiedad (
			atributo <- children->collect(e | thisModule.PropertyCallExp2Atributo(e)),  
			termino <- t
		),
		t: LNR!Termino (
			indeterminante <- 'un/una' --,
		)
	do {
		if(not parentIteratorName.oclIsUndefined()) { --translate exists as size
		  if(parentIteratorName = 'exists') {
			p.atributo.first().prefijo <- 'cantidad de'	;
		  } 
		 }
		t.contexto <- thisModule.removePrefix(children.last().ownedSource.type.
				toString());
	}
}

lazy rule OperationCallExp2Propiedad {
	from
		s: OCL!OperationCallExp
	using {
		children: Sequence(OCL!PropertyCallExp) = s.ownedSource.
				getPropertyCallExpCollection();
	}
	to
		p: LNR!Propiedad (
			atributo  <- children->collect(e | thisModule.PropertyCallExp2Atributo(e)),
			termino   <- t,
			iteracion <- if (s.ownedSource.oclIsTypeOf(OCL!IteratorExp)) then 
							it
						else OclUndefined
						endif
		),
		t: LNR!Termino (
			indeterminante <- 'un/una',
			contexto <- if (s.oclIsUndefined()) then
					OclUndefined
				else
					s.getExpressionInOCL().owningConstraint.context.name
				endif
		)
		,
		it: LNR!Iteracion (	
			conector <-
						if (s.ownedSource.oclIsTypeOf(OCL!IteratorExp)) then 
							'tal que'
						else OclUndefined
						endif
						, 
			contenido <- if (s.ownedSource.oclIsTypeOf(OCL!IteratorExp)) then 
							s.ownedSource.ownedBody
						else OclUndefined
						endif
			)
	do {
			p.atributo.first().prefijo <- 'cantidad de';
	}
}


lazy rule IteratorExp2Propiedad {
	from
		s: OCL!IteratorExp
	using {
		children: Sequence(OCL!PropertyCallExp) = s.ownedSource.
				getPropertyCallExpCollection();
		iterators: Sequence(OCL!IteratorExp) = s.getIteratorExpCollection();
	}
	to
		p: LNR!Propiedad (
			atributo <- children->collect(e | thisModule.PropertyCallExp2Atributo(e)),
			termino <- t,
			iteracion <- iterators->collect(e | thisModule.IteratorExp2Iteracion(e))

		),
		t: LNR!Termino (
			indeterminante <- 'un/una',
			contexto <- if (s.oclIsUndefined()) then
					OclUndefined
				else
					s.getExpressionInOCL().owningConstraint.context.name
				endif
		)

	do { 
		
		if (iterators.first().referredIteration.name = 'select'){ 
				p.atributo.first().determinante <- 'entre los';
		} else {
				if (iterators.first().referredIteration.name = 'exists') {
					p.atributo.first().determinante <- 'existe un';
				} else {
					p.atributo.first().determinante <- 'todos los/las';
					}
			}
		}
}


lazy rule IteratorExp2Iteracion{
from
		s: OCL!IteratorExp
	to
		it: LNR!Iteracion (	
			conector <- if (s.referredIteration.name = 'forAll') then 'satisfacen que' 
						else if (s.referredIteration.name = 'exists') then 'existe uno tal que' 
							 else 'tal que'
							 endif	 
						endif, 
			contenido <- s.ownedBody
			)
	}